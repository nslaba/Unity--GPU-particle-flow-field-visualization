// This shader handles the particles. It reads the vector field data and updates the positions 
// movements of the particles based on the vector field data
#pragma kernel UpdateParticles

struct Particle {
    float3 position;
    float3 velocity;
    float4 color;
    float3 force;
    float size;
    float lifetime;
};



// Initialize the vector field that will share data with the CircularField compute shader :)
RWTexture2D<float4> _VectorField; // stores 4 floats per pixel
uniform float2 _VectorFieldSize;
RWStructuredBuffer<Particle> particles;


// Variables from the CPU
float deltaTime;
float2 mousePosition;

//[numthreads(64, 8, 1)]
[numthreads(256, 1, 1)]
void UpdateParticles(uint3 id: SV_DispatchThreadID) {

    Particle p = particles[id.x];
    float3 pos = p.position;
    float3 vel = p.velocity;
    float4 color = p.color;
    float3 force = p.force;
    float size = p.size;
    float lifetime = p.lifetime - deltaTime;

    // Deal with mouse
    float3 delta = float3(mousePosition.xy, 3) - particles[id.x].position;
    float3 direction = normalize(delta);

    // Sample the vector field at the current particle position 
    float u = pos.x / 1920.0f;
    float v = pos.y / 1080.0f;

    // access the texture in texture coordinates which range from 0,1
    

    // Map the pos world space to screen space
    pos.x += 1920/2.0f;
    pos.y += 1080/2.0f;
    // Normalize the screen space vals to texture space which lies between 0 and 1
    uint2 texCoord = uint2(pos.xy / _VectorFieldSize.xy);
    float4 texel = _VectorField.Load(int3(texCoord, 0)); // should load the RG texel which should be between 0 and 1
    // Determine the sign of the texel
    // float xSign = (texel.x * 2.0 - 1.0) * sign(vel.x);
    // float ySign = (texel.y * 2.0 - 1.0) * sign(vel.y);
    
    // Update velocity based on sign
    // vel.x += xSign * deltaTime;
    // vel.y += ySign * deltaTime;
    //float3(texel.xy, 0.0) 
    vel += float3(texel.xy, 0.0) * direction * deltaTime;


    // Update particle position based on vel and time
    p.position += vel * deltaTime;

    // for now keep color, force, size and lifetime the same
    if (lifetime < 0.0)
    { 
        // destroy the particle somehow or do something
        // p.color.w = 0;
    }

    // Write back updated particle data
    p.velocity = vel;
    p.lifetime = lifetime;
    
    particles[id.x] = p;
}
